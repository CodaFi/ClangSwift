/// IMPORTANT: This file is automatically generated.
import cclang

/// MARK: Customized Types

internal protocol FunctionLikeDecl: ClangCursorBacked {}

public struct FunctionDecl: ClangCursorBacked {
    let clang: CXCursor

    init(clang: CXCursor) {
        self.clang = clang
    }

    /// Retrieve the argument cursor of a function or method.
    /// The argument cursor can be determined for calls as well as for
    /// declarations of functions or methods.
    public func parameter(at index: Int) -> Cursor? {
        return convertCursor(clang_Cursor_getArgument(clang, UInt32(index)))
    }

    /// Retrieve the return type of the function.
    public var resultType: CType? {
        return convertType(clang_getCursorResultType(clang))
    }
}

protocol MethodDecl: ClangCursorBacked {}
extension MethodDecl {

    /// Determine the set of methods that are overridden by the given method.
    /// In both Objective-C and C++, a method (aka virtual member function, in
    /// C++) can override a virtual method in a base class. For Objective-C, a
    /// method is said to override any method in the class's base class, its
    /// protocols, or its categories' protocols, that has the same selector and
    /// is of the same kind (class or instance). If no such method exists, the
    /// search continues to the class's superclass, its protocols, and its
    /// categories, and so on. A method from an Objective-C implementation is
    /// considered to override the same methods as its corresponding method in
    /// the interface.
    ///
    /// For C++, a virtual member function overrides any virtual member function
    /// with the same signature that occurs in its base classes. With multiple
    /// inheritance, a virtual member function can override several virtual
    /// member functions coming from different base classes.
    ///
    /// In all cases, this will return the immediate overridden method,
    /// rather than all of the overridden methods. For example, if a method is
    /// originally declared in a class A, then overridden in B (which in
    /// inherits from A) and also in C (which inherited from B), then the only
    /// overridden method returned from this function when invoked on C's method
    /// will be B's method. The client may then invoke this function again,
    /// given the previously-found overridden methods, to map out the complete
    /// method-override set.
    public var overrides: [Cursor] {
        var overridden: UnsafeMutablePointer<CXCursor>?
        var overrideCount = 0 as UInt32
        clang_getOverriddenCursors(clang, &overridden, &overrideCount)
        guard let overriddenPtr = overridden else { return [] }
        var overrides = [Cursor]()
        for i in 0..<Int(overrideCount) {
            if let cursor = convertCursor(overriddenPtr[i]) {
                overrides.append(cursor)
            }
        }
        clang_disposeOverriddenCursors(overridden)
        return overrides
    }
}

public struct InclusionDirective: ClangCursorBacked {
    let clang: CXCursor

    /// Retrieve the file that is included by the given inclusion directive.
    public var includedFile: File? {
        return File(clang: clang_getIncludedFile(asClang()))
    }
}

protocol RecordDecl: ClangCursorBacked {}
extension RecordDecl {
    func fields() -> [Cursor] {
        guard let type = type as? RecordType else { return [] }
        return type.fields()
    }
}

public struct StructDecl: RecordDecl {
    let clang: CXCursor
}

public struct ClassDecl: RecordDecl {
    let clang: CXCursor
}

public struct EnumConstantDecl: ClangCursorBacked {
    let clang: CXCursor

    /// Retrieve the integer type of an enum declaration.
    var integerType: CType {
        return convertType(clang_getEnumDeclIntegerType(clang))!
    }

    /// Retrieve the integer value of an enum constant declaration as an `Int`.
    var value: Int {
        return Int(clang_getEnumConstantDeclValue(clang))
    }

    /// Retrieve the integer value of an enum constant declaration as a `UInt`.
    var unsignedValue: UInt {
        return UInt(clang_getEnumConstantDeclUnsignedValue(clang))
    }
}

public struct EnumDecl: ClangCursorBacked {
    let clang: CXCursor

    func constants() -> [EnumConstantDecl] {
        return children() as! [EnumConstantDecl]
    }
}

protocol TypeAliasCursor: ClangCursorBacked {}
extension TypeAliasCursor {
    /// Retrieve the underlying type of a typedef declaration.
    var underlying: CType? {
        return convertType(clang_getTypedefDeclUnderlyingType(clang))
    }
}

public struct TypedefDecl: TypeAliasCursor { let clang: CXCursor }
public struct TypeAliasDecl: TypeAliasCursor { let clang: CXCursor }
public struct UsingDirective: TypeAliasCursor { let clang: CXCursor }
public struct UsingDeclaration: TypeAliasCursor { let clang: CXCursor }

/// MARK: Standard Types

public struct UnexposedDecl: ClangCursorBacked { let clang: CXCursor }
public struct UnionDecl: ClangCursorBacked { let clang: CXCursor }
public struct FieldDecl: ClangCursorBacked { let clang: CXCursor }
public struct VarDecl: ClangCursorBacked { let clang: CXCursor }
public struct ParmDecl: ClangCursorBacked { let clang: CXCursor }
public struct ObjCInterfaceDecl: ClangCursorBacked { let clang: CXCursor }
public struct ObjCCategoryDecl: ClangCursorBacked { let clang: CXCursor }
public struct ObjCProtocolDecl: ClangCursorBacked { let clang: CXCursor }
public struct ObjCPropertyDecl: ClangCursorBacked { let clang: CXCursor }
public struct ObjCIvarDecl: ClangCursorBacked { let clang: CXCursor }
public struct ObjCInstanceMethodDecl: MethodDecl { let clang: CXCursor }
public struct ObjCClassMethodDecl: MethodDecl { let clang: CXCursor }
public struct ObjCImplementationDecl: ClangCursorBacked { let clang: CXCursor }
public struct ObjCCategoryImplDecl: ClangCursorBacked { let clang: CXCursor }
public struct CXXMethod: MethodDecl { let clang: CXCursor }
public struct Namespace: ClangCursorBacked { let clang: CXCursor }
public struct LinkageSpec: ClangCursorBacked { let clang: CXCursor }
public struct Constructor: ClangCursorBacked { let clang: CXCursor }
public struct Destructor: ClangCursorBacked { let clang: CXCursor }
public struct ConversionFunction: ClangCursorBacked { let clang: CXCursor }
public struct TemplateTypeParameter: ClangCursorBacked { let clang: CXCursor }
public struct NonTypeTemplateParameter: ClangCursorBacked { let clang: CXCursor }
public struct TemplateTemplateParameter: ClangCursorBacked { let clang: CXCursor }
public struct FunctionTemplate: ClangCursorBacked { let clang: CXCursor }
public struct ClassTemplate: ClangCursorBacked { let clang: CXCursor }
public struct ClassTemplatePartialSpecialization: ClangCursorBacked { let clang: CXCursor }
public struct NamespaceAlias: ClangCursorBacked { let clang: CXCursor }
public struct ObjCSynthesizeDecl: ClangCursorBacked { let clang: CXCursor }
public struct ObjCDynamicDecl: ClangCursorBacked { let clang: CXCursor }
public struct CXXAccessSpecifier: ClangCursorBacked { let clang: CXCursor }
public struct ObjCSuperClassRef: ClangCursorBacked { let clang: CXCursor }
public struct ObjCProtocolRef: ClangCursorBacked { let clang: CXCursor }
public struct ObjCClassRef: ClangCursorBacked { let clang: CXCursor }
public struct TypeRef: ClangCursorBacked { let clang: CXCursor }
public struct CXXBaseSpecifier: ClangCursorBacked { let clang: CXCursor }
public struct TemplateRef: ClangCursorBacked { let clang: CXCursor }
public struct NamespaceRef: ClangCursorBacked { let clang: CXCursor }
public struct MemberRef: ClangCursorBacked { let clang: CXCursor }
public struct LabelRef: ClangCursorBacked { let clang: CXCursor }
public struct OverloadedDeclRef: ClangCursorBacked { let clang: CXCursor }
public struct VariableRef: ClangCursorBacked { let clang: CXCursor }
public struct InvalidFile: ClangCursorBacked { let clang: CXCursor }
public struct NoDeclFound: ClangCursorBacked { let clang: CXCursor }
public struct NotImplemented: ClangCursorBacked { let clang: CXCursor }
public struct InvalidCode: ClangCursorBacked { let clang: CXCursor }
public struct UnexposedExpr: ClangCursorBacked { let clang: CXCursor }
public struct DeclRefExpr: ClangCursorBacked { let clang: CXCursor }
public struct MemberRefExpr: ClangCursorBacked { let clang: CXCursor }
public struct CallExpr: ClangCursorBacked { let clang: CXCursor }
public struct ObjCMessageExpr: ClangCursorBacked { let clang: CXCursor }
public struct BlockExpr: ClangCursorBacked { let clang: CXCursor }
public struct IntegerLiteral: ClangCursorBacked { let clang: CXCursor }
public struct FloatingLiteral: ClangCursorBacked { let clang: CXCursor }
public struct ImaginaryLiteral: ClangCursorBacked { let clang: CXCursor }
public struct StringLiteral: ClangCursorBacked { let clang: CXCursor }
public struct CharacterLiteral: ClangCursorBacked { let clang: CXCursor }
public struct ParenExpr: ClangCursorBacked { let clang: CXCursor }
public struct UnaryOperator: ClangCursorBacked { let clang: CXCursor }
public struct ArraySubscriptExpr: ClangCursorBacked { let clang: CXCursor }
public struct BinaryOperator: ClangCursorBacked { let clang: CXCursor }
public struct CompoundAssignOperator: ClangCursorBacked { let clang: CXCursor }
public struct ConditionalOperator: ClangCursorBacked { let clang: CXCursor }
public struct CStyleCastExpr: ClangCursorBacked { let clang: CXCursor }
public struct CompoundLiteralExpr: ClangCursorBacked { let clang: CXCursor }
public struct InitListExpr: ClangCursorBacked { let clang: CXCursor }
public struct AddrLabelExpr: ClangCursorBacked { let clang: CXCursor }
public struct StmtExpr: ClangCursorBacked { let clang: CXCursor }
public struct GenericSelectionExpr: ClangCursorBacked { let clang: CXCursor }
public struct GNUNullExpr: ClangCursorBacked { let clang: CXCursor }
public struct CXXStaticCastExpr: ClangCursorBacked { let clang: CXCursor }
public struct CXXDynamicCastExpr: ClangCursorBacked { let clang: CXCursor }
public struct CXXReinterpretCastExpr: ClangCursorBacked { let clang: CXCursor }
public struct CXXConstCastExpr: ClangCursorBacked { let clang: CXCursor }
public struct CXXFunctionalCastExpr: ClangCursorBacked { let clang: CXCursor }
public struct CXXTypeidExpr: ClangCursorBacked { let clang: CXCursor }
public struct CXXBoolLiteralExpr: ClangCursorBacked { let clang: CXCursor }
public struct CXXNullPtrLiteralExpr: ClangCursorBacked { let clang: CXCursor }
public struct CXXThisExpr: ClangCursorBacked { let clang: CXCursor }
public struct CXXThrowExpr: ClangCursorBacked { let clang: CXCursor }
public struct CXXNewExpr: ClangCursorBacked { let clang: CXCursor }
public struct CXXDeleteExpr: ClangCursorBacked { let clang: CXCursor }
public struct UnaryExpr: ClangCursorBacked { let clang: CXCursor }
public struct ObjCStringLiteral: ClangCursorBacked { let clang: CXCursor }
public struct ObjCEncodeExpr: ClangCursorBacked { let clang: CXCursor }
public struct ObjCSelectorExpr: ClangCursorBacked { let clang: CXCursor }
public struct ObjCProtocolExpr: ClangCursorBacked { let clang: CXCursor }
public struct ObjCBridgedCastExpr: ClangCursorBacked { let clang: CXCursor }
public struct PackExpansionExpr: ClangCursorBacked { let clang: CXCursor }
public struct SizeOfPackExpr: ClangCursorBacked { let clang: CXCursor }
public struct LambdaExpr: ClangCursorBacked { let clang: CXCursor }
public struct ObjCBoolLiteralExpr: ClangCursorBacked { let clang: CXCursor }
public struct ObjCSelfExpr: ClangCursorBacked { let clang: CXCursor }
public struct OMPArraySectionExpr: ClangCursorBacked { let clang: CXCursor }
public struct ObjCAvailabilityCheckExpr: ClangCursorBacked { let clang: CXCursor }
public struct UnexposedStmt: ClangCursorBacked { let clang: CXCursor }
public struct LabelStmt: ClangCursorBacked { let clang: CXCursor }
public struct CompoundStmt: ClangCursorBacked { let clang: CXCursor }
public struct CaseStmt: ClangCursorBacked { let clang: CXCursor }
public struct DefaultStmt: ClangCursorBacked { let clang: CXCursor }
public struct IfStmt: ClangCursorBacked { let clang: CXCursor }
public struct SwitchStmt: ClangCursorBacked { let clang: CXCursor }
public struct WhileStmt: ClangCursorBacked { let clang: CXCursor }
public struct DoStmt: ClangCursorBacked { let clang: CXCursor }
public struct ForStmt: ClangCursorBacked { let clang: CXCursor }
public struct GotoStmt: ClangCursorBacked { let clang: CXCursor }
public struct IndirectGotoStmt: ClangCursorBacked { let clang: CXCursor }
public struct ContinueStmt: ClangCursorBacked { let clang: CXCursor }
public struct BreakStmt: ClangCursorBacked { let clang: CXCursor }
public struct ReturnStmt: ClangCursorBacked { let clang: CXCursor }
public struct GCCAsmStmt: ClangCursorBacked { let clang: CXCursor }
public struct AsmStmt: ClangCursorBacked { let clang: CXCursor }
public struct ObjCAtTryStmt: ClangCursorBacked { let clang: CXCursor }
public struct ObjCAtCatchStmt: ClangCursorBacked { let clang: CXCursor }
public struct ObjCAtFinallyStmt: ClangCursorBacked { let clang: CXCursor }
public struct ObjCAtThrowStmt: ClangCursorBacked { let clang: CXCursor }
public struct ObjCAtSynchronizedStmt: ClangCursorBacked { let clang: CXCursor }
public struct ObjCAutoreleasePoolStmt: ClangCursorBacked { let clang: CXCursor }
public struct ObjCForCollectionStmt: ClangCursorBacked { let clang: CXCursor }
public struct CXXCatchStmt: ClangCursorBacked { let clang: CXCursor }
public struct CXXTryStmt: ClangCursorBacked { let clang: CXCursor }
public struct CXXForRangeStmt: ClangCursorBacked { let clang: CXCursor }
public struct SEHTryStmt: ClangCursorBacked { let clang: CXCursor }
public struct SEHExceptStmt: ClangCursorBacked { let clang: CXCursor }
public struct SEHFinallyStmt: ClangCursorBacked { let clang: CXCursor }
public struct MSAsmStmt: ClangCursorBacked { let clang: CXCursor }
public struct NullStmt: ClangCursorBacked { let clang: CXCursor }
public struct DeclStmt: ClangCursorBacked { let clang: CXCursor }
public struct OMPParallelDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPSimdDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPForDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPSectionsDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPSectionDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPSingleDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPParallelForDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPParallelSectionsDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPTaskDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPMasterDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPCriticalDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPTaskyieldDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPBarrierDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPTaskwaitDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPFlushDirective: ClangCursorBacked { let clang: CXCursor }
public struct SEHLeaveStmt: ClangCursorBacked { let clang: CXCursor }
public struct OMPOrderedDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPAtomicDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPForSimdDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPParallelForSimdDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPTargetDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPTeamsDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPTaskgroupDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPCancellationPointDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPCancelDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPTargetDataDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPTaskLoopDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPTaskLoopSimdDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPDistributeDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPTargetEnterDataDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPTargetExitDataDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPTargetParallelDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPTargetParallelForDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPTargetUpdateDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPDistributeParallelForDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPDistributeParallelForSimdDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPDistributeSimdDirective: ClangCursorBacked { let clang: CXCursor }
public struct OMPTargetParallelForSimdDirective: ClangCursorBacked { let clang: CXCursor }
public struct TranslationUnitCursor: ClangCursorBacked { let clang: CXCursor }
public struct UnexposedAttr: ClangCursorBacked { let clang: CXCursor }
public struct IBActionAttr: ClangCursorBacked { let clang: CXCursor }
public struct IBOutletAttr: ClangCursorBacked { let clang: CXCursor }
public struct IBOutletCollectionAttr: ClangCursorBacked { let clang: CXCursor }
public struct CXXFinalAttr: ClangCursorBacked { let clang: CXCursor }
public struct CXXOverrideAttr: ClangCursorBacked { let clang: CXCursor }
public struct AnnotateAttr: ClangCursorBacked { let clang: CXCursor }
public struct AsmLabelAttr: ClangCursorBacked { let clang: CXCursor }
public struct PackedAttr: ClangCursorBacked { let clang: CXCursor }
public struct PureAttr: ClangCursorBacked { let clang: CXCursor }
public struct ConstAttr: ClangCursorBacked { let clang: CXCursor }
public struct NoDuplicateAttr: ClangCursorBacked { let clang: CXCursor }
public struct CUDAConstantAttr: ClangCursorBacked { let clang: CXCursor }
public struct CUDADeviceAttr: ClangCursorBacked { let clang: CXCursor }
public struct CUDAGlobalAttr: ClangCursorBacked { let clang: CXCursor }
public struct CUDAHostAttr: ClangCursorBacked { let clang: CXCursor }
public struct CUDASharedAttr: ClangCursorBacked { let clang: CXCursor }
public struct VisibilityAttr: ClangCursorBacked { let clang: CXCursor }
public struct DLLExport: ClangCursorBacked { let clang: CXCursor }
public struct DLLImport: ClangCursorBacked { let clang: CXCursor }
public struct PreprocessingDirective: ClangCursorBacked { let clang: CXCursor }
public struct MacroDefinition: ClangCursorBacked { let clang: CXCursor }
public struct MacroExpansion: ClangCursorBacked { let clang: CXCursor }
public struct MacroInstantiation: ClangCursorBacked { let clang: CXCursor }
public struct ModuleImportDecl: ClangCursorBacked { let clang: CXCursor }
public struct TypeAliasTemplateDecl: ClangCursorBacked { let clang: CXCursor }
public struct StaticAssert: ClangCursorBacked { let clang: CXCursor }
public struct FriendDecl: ClangCursorBacked { let clang: CXCursor }
public struct OverloadCandidate: ClangCursorBacked { let clang: CXCursor }
