/// IMPORTANT: This file is automatically generated.
import cclang

/// MARK: Special Types

struct RecordType: ClangTypeBacked {
    let clang: CXType

    /// Computes the offset of a named field in a record of the given type
    /// in bytes as it would be returned by __offsetof__ as per C++11[18.2p4]
    /// - returns: The offset of a field with the given name in the type.
    /// - throws:
    ///     - `TypeLayoutError.invalid` if the type declaration is not a record
    ///        field.
    ///     - `TypeLayoutError.incomplete` if the type declaration is an
    ///       incomplete type
    ///     - `TypeLayoutError.dependent` if the type declaration is dependent
    ///     - `TypeLayoutError.invalidFieldName` if the field is not found in
    ///       the receiving type.
    public func offsetOf(fieldName: String) throws -> Int {
        let val = clang_Type_getOffsetOf(asClang(), fieldName)
        if let error = TypeLayoutError(clang: CXTypeLayoutError(rawValue: Int32(val))) {
            throw error
        }
        return Int(val)
    }

    /// Gathers and returns all the fields of this record.
    func fields() -> [Cursor] {
        let fields = Box([Cursor]())
        let fieldsRef = Unmanaged.passUnretained(fields)
        let opaque = fieldsRef.toOpaque()

        clang_Type_visitFields(asClang(), { (child, opaque) -> CXVisitorResult in
            let fieldsRef = Unmanaged<Box<[Cursor]>>.fromOpaque(opaque!)
            let fields = fieldsRef.takeUnretainedValue()
            if let cursor = convertCursor(child) {
                fields.value.append(cursor)
            }
            return CXVisit_Continue
        }, opaque)

        return fields.value
    }
}

/// MARK: Standard Types

public struct UnexposedType: ClangTypeBacked { let clang: CXType }
public struct VoidType: ClangTypeBacked { let clang: CXType }
public struct BoolType: ClangTypeBacked { let clang: CXType }
public struct CharUType: ClangTypeBacked { let clang: CXType }
public struct UCharType: ClangTypeBacked { let clang: CXType }
public struct Char16Type: ClangTypeBacked { let clang: CXType }
public struct Char32Type: ClangTypeBacked { let clang: CXType }
public struct UShortType: ClangTypeBacked { let clang: CXType }
public struct UIntType: ClangTypeBacked { let clang: CXType }
public struct ULongType: ClangTypeBacked { let clang: CXType }
public struct ULongLongType: ClangTypeBacked { let clang: CXType }
public struct UInt128Type: ClangTypeBacked { let clang: CXType }
public struct CharSType: ClangTypeBacked { let clang: CXType }
public struct SCharType: ClangTypeBacked { let clang: CXType }
public struct WCharType: ClangTypeBacked { let clang: CXType }
public struct ShortType: ClangTypeBacked { let clang: CXType }
public struct IntType: ClangTypeBacked { let clang: CXType }
public struct LongType: ClangTypeBacked { let clang: CXType }
public struct LongLongType: ClangTypeBacked { let clang: CXType }
public struct Int128Type: ClangTypeBacked { let clang: CXType }
public struct FloatType: ClangTypeBacked { let clang: CXType }
public struct DoubleType: ClangTypeBacked { let clang: CXType }
public struct LongDoubleType: ClangTypeBacked { let clang: CXType }
public struct NullPtrType: ClangTypeBacked { let clang: CXType }
public struct OverloadType: ClangTypeBacked { let clang: CXType }
public struct DependentType: ClangTypeBacked { let clang: CXType }
public struct ObjCIdType: ClangTypeBacked { let clang: CXType }
public struct ObjCClassType: ClangTypeBacked { let clang: CXType }
public struct ObjCSelType: ClangTypeBacked { let clang: CXType }
public struct Float128Type: ClangTypeBacked { let clang: CXType }
public struct ComplexType: ClangTypeBacked { let clang: CXType }
public struct PointerType: ClangTypeBacked { let clang: CXType }
public struct BlockPointerType: ClangTypeBacked { let clang: CXType }
public struct LValueReferenceType: ClangTypeBacked { let clang: CXType }
public struct RValueReferenceType: ClangTypeBacked { let clang: CXType }
public struct EnumType: ClangTypeBacked { let clang: CXType }
public struct TypedefType: ClangTypeBacked { let clang: CXType }
public struct ObjCInterfaceType: ClangTypeBacked { let clang: CXType }
public struct ObjCObjectPointerType: ClangTypeBacked { let clang: CXType }
public struct FunctionNoProtoType: ClangTypeBacked { let clang: CXType }
public struct FunctionProtoType: ClangTypeBacked { let clang: CXType }
public struct ConstantArrayType: ClangTypeBacked { let clang: CXType }
public struct VectorType: ClangTypeBacked { let clang: CXType }
public struct IncompleteArrayType: ClangTypeBacked { let clang: CXType }
public struct VariableArrayType: ClangTypeBacked { let clang: CXType }
public struct DependentSizedArrayType: ClangTypeBacked { let clang: CXType }
public struct MemberPointerType: ClangTypeBacked { let clang: CXType }
public struct AutoType: ClangTypeBacked { let clang: CXType }
public struct ElaboratedType: ClangTypeBacked { let clang: CXType }
public struct Type: ClangTypeBacked { let clang: CXType }
